

## React 如何处理渲染？

### 排队渲染

初始渲染完成后，有几种不同的方式告诉 React 排队重新渲染：

- 函数组件
  - `useState`setters
  - `useReducer`dispatch
- 类组件
  - `this.setState()`
  - `this.forceUpdate()`
- 其他
  - 再次调用 ReactDOM 顶层 `render(<App>)` 方法（相当于在根组件上调用 `forceUpdate()`）
  - 从新的 `useSyncExternalStore` 挂钩触发的更新

请注意，函数组件没有 `forceUpdate` 方法，但您可以通过使用始终递增计数器的 `useReducer` 挂钩获得相同的行为：

```js
const [, forceRender] = useReducer((c) => c + 1, 0);
```


### 标准渲染行为

记住这一点非常重要：

**React 的默认行为是当一个父组件渲染时，React 将递归地渲染它里面的所有子组件！**

例如，假设我们有一个 `A > B > C > D` 的组件树，并且我们已经在页面上显示了它们。用户单击 `B` 中的一个按钮，该按钮会增加一个计数器：

  - 我们在 `B` 中调用 `setState()`，它将 `B` 的重新渲染排队。
  - React 从树的顶部开始渲染过程
  - React 看到 `A` 没有被标记为需要更新，并跳过它
  - React 看到 `B` 被标记为需要更新，并渲染它。 `B` 像上次一样返回 `<C /> `。
  - `C` 最初没有标记为需要更新。然而，因为它的父 `B` 渲染了，React 现在向下移动并渲染 `C`。 `C` 再次返回 `<D />`。
  - `D` 也没有标记为渲染，但是由于它的父级 `C` 渲染了，React 向下移动并渲染 `D`。

以另一种方式重复这个：

默认情况下，渲染一个组件会导致它内部的所有组件也被渲染！

另外，还有一个关键点：

在正常渲染中，React 不关心“props 是否改变”——它会无条件地渲染子组件，因为父组件渲染了！

这意味着在你的根 `<App>` 组件中调用 `setState()` ，没有其他改变改变行为，将导致 React 重新渲染组件树中的每个组件。 毕竟，React 最初的销售宣传之一是“就像我们在每次更新时重新绘制整个应用程序一样”。

现在，树中的大部分组件很可能会返回与上次完全相同的渲染输出，因此 React 不需要对 DOM 进行任何更改。 但是，React 仍然需要完成要求组件自行渲染和区分渲染输出的工作。 这两者都需要时间和精力。

请记住，渲染并不是一件坏事——它是 React 知道它是否需要实际对 DOM 进行任何更改的方式！